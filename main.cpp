#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdint.h>
#include <vector>
#include <array>
#include <cmath>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"


constexpr int    image_scale  = 40;
constexpr int    image_width  = image_scale * 16;
constexpr int    image_height = image_scale * 9;
constexpr double aspect_scale = image_height / double(image_width);

constexpr double P0_width  = 36;
constexpr double P0_height = P0_width * aspect_scale;
constexpr double t_start   = 0;
constexpr double t_end     = 20000;
constexpr int    num_steps = 8192;
constexpr double dt        = (t_end - t_start) / num_steps;



template <int n, typename real_type>
struct vecn
{
	real_type e[n];

	inline constexpr vecn operator+(const vecn & rhs) const { vecn r; for (int z = 0; z < n; ++z) r.e[z] = e[z] + rhs.e[z]; return r; }
	inline constexpr vecn operator-(const vecn & rhs) const { vecn r; for (int z = 0; z < n; ++z) r.e[z] = e[z] - rhs.e[z]; return r; }

	inline constexpr vecn operator*(const real_type rhs) const { vecn r; for (int z = 0; z < n; ++z) r.e[z] = e[z] *      rhs;  return r; }
	inline constexpr vecn operator/(const real_type rhs) const { vecn r; for (int z = 0; z < n; ++z) r.e[z] = e[z] * (1 / rhs); return r; }

	inline constexpr static real_type dot(const vecn & a, const vecn & b)
	{
		real_type r = 0;
		for (int z = 0; z < n; ++z)
			r += a.e[z] * b.e[z];
		return r;
	}

	inline constexpr static real_type length(const vecn & v) { return std::sqrt(dot(v, v)); }

	inline constexpr real_type x() const { return e[0]; }
	inline constexpr real_type y() const { return e[1]; }
	inline constexpr real_type z() const { return e[2]; }
};

using vec2d = vecn<2, double>;
//using vec3f = vecn<3, float>;


inline vec2d dPdt(const vec2d & P)
{
#if 0
	// Lotka-Volterra
	constexpr double alpha = 2 / 3.0;
	constexpr double beta  = 4 / 3.0;
	constexpr double gamma = 1;
	constexpr double delta = 1;

	return {
		alpha * P.x() - beta * P.x() * P.y(),
		delta * P.x() * P.y() - gamma * P.y() };
#else
	const double k = 2.0;
	const double r = 0.1;
	const double h = 0.45;
	const double v = 1.5;
	const double b = 1.3;
	const double s = 0.1;
	const double c = 0.25;

#if 1
	const double dxdt = P.x() * r * (1 - (P.x() / k)) - P.y() * v * (P.x() / (v + P.x() * h + b * (P.x() * P.x())));
	const double dydt = c * P.y() * v * (P.x() / (v + P.x() * h + b * (P.x() * P.x()))) - P.y() * s;
#else
	const double n = 1;
	const double m = 3.5;

	const double dxdt = P.x * r * (1 - (P.x / k)) - P.y * ((v * std::pow(P.x, n)) / ((1 + (v * h * std::pow(P.x, m)))));
	const double dydt = c * P.y * ((v * std::pow(P.x, n)) / (1 + (v * h * std::pow(P.x, m))))- P.y * s;
#endif
	return vec2d{ dxdt, dydt };
#endif
}


inline double sign(double v) { return (v >= 0) ? 1.0 : -1.0; }

// Convert uniform distribution into triangle-shaped distribution
// From https://www.shadertoy.com/view/4t2SDh
inline double triDist(double v)
{
	const double orig = v * 2 - 1;
	v = orig / std::sqrt(std::fabs(orig));
	v = std::max(-1.0, v); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
	v = v - sign(orig);

	return v;
}


// Hash function by Thomas Wang: https://burtleburtle.net/bob/hash/integer.html
inline uint32_t hash(uint32_t x)
{
	x  = (x ^ 12345391) * 2654435769;
	x ^= (x << 6) ^ (x >> 26);
	x *= 2654435769;
	x += (x << 5) ^ (x >> 12);

	return x;
}


void main()
{
	struct pixel8bit { uint8_t r, g, b, a; };
	std::vector<pixel8bit> image_ldr(image_width * image_height);
	std::vector<double>  lyapunov_l2(image_width * image_height, 0.0f);

	constexpr vec2d pixel_step = { 0.7548776662466927600500267982588, 0.56984029099805326591218186327522 };
	const double inf = -std::log(0.0);

	int current_pass = 0;
	vec2d pixel_offset = { 0.5, 0.5 };
	while (true)
	{
		#pragma omp parallel
		for (int pixel_idx = 0; pixel_idx < image_width * image_height; ++pixel_idx)
		{
			const int y = pixel_idx / image_width;
			const int x = pixel_idx - image_width * y;
			const double u01 = hash(pixel_idx) / double(1ull << 32);
			const double u0 = u01 + pixel_offset.e[0];
			const double u1 = u01 + pixel_offset.e[1];
			const double P0_x =                     (x + triDist((u0 < 1) ? u0 : u0 - 1) + 0.5)  * (1.0 / image_width)  * P0_width - 7;
			const double P0_y = (image_height - 1 - (y + triDist((u1 < 1) ? u1 : u1 - 1) + 0.5)) * (1.0 / image_height) * P0_height; // Y+ is down in screenspace

			// Compute Lyapunov exponent, see https://en.wikipedia.org/wiki/Lyapunov_exponent
			vec2d P = { P0_x, P0_y };
			double log_len_sum = 0;
			bool valid = true;
			for (int step = 0; step < num_steps; ++step)
			{
				// Do prediction-correction steps to better approximate derivative at midpoint of interval
				vec2d dPdt_current = dPdt(P);
				for (int z = 0; z < 1; z++)
				{
					const vec2d P_mid = P + dPdt_current * (dt * 0.5);
					dPdt_current = dPdt(P_mid);
				}

				log_len_sum += std::log(vec2d::dot(dPdt_current, dPdt_current)); // TODO use log2?
				if (!std::isfinite(log_len_sum)) { valid = false; break; }

				// Step to the next point
				P = P + dPdt_current * dt;
			}

			double v;
			if (valid)
			{
				const double log_len_avg = std::abs(log_len_sum * (0.5 / num_steps));
				v = std::exp(log_len_avg * 0.125) * 0.0005;
			}
			else v = 0;

			// Accumulate running average
			const double pixel_acc = lyapunov_l2[pixel_idx] + v;
			const double pixel_avg = pixel_acc / (current_pass + 1);
			lyapunov_l2[pixel_idx] = pixel_acc;

			const auto sRGB = [](float u) -> float { return (u <= 0.0031308f) ? 12.92f * u : 1.055f * std::pow(u, 0.416667f) - 0.055f; };
			const float pixel_sRGB = sRGB((float)pixel_avg);
			image_ldr[pixel_idx].r = std::max(0, std::min(255, int(pixel_sRGB * 255 + 0.5f)));
			image_ldr[pixel_idx].g = std::max(0, std::min(255, int(pixel_sRGB * 255 + 0.5f)));
			image_ldr[pixel_idx].b = std::max(0, std::min(255, int(pixel_sRGB * 255 + 0.5f)));
			image_ldr[pixel_idx].a = 255;
		}

		stbi_write_png("lyapunov_l2.png", image_width, image_height, 4, &image_ldr[0], image_width * 4);

		printf("Finished pass %d\n", current_pass);

		pixel_offset = pixel_offset + pixel_step;
		if (pixel_offset.e[0] >= 1) pixel_offset.e[0] -= 1;
		if (pixel_offset.e[1] >= 1) pixel_offset.e[1] -= 1;

		++current_pass;
	}
}
